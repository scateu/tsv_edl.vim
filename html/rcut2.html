<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta http-equiv="Content-Security-Policy" content="media-src http: https: 'self' 'unsafe-inline'">
      <meta http-equiv="Access-Control-Allow-Origin" content="*" />
      <!-- FIXME Safari can't visit http resource in https page -->
      <title>rCut</title>
      <style>
	html, body {
		overscroll-behavior: none;
		/*overflow: hidden;*/
		-webkit-overflow-scrolling: auto;
		overflow-scrolling: auto;
	}
	body {
		font-family: Arial, sans-serif;
		margin: 20px;
		background-color: #f0f0f0;
	}
	.container {
		max-width: 1200px;
		margin: 0 auto;
	}
	.video-container {
		width: 100%;
		/*margin-bottom: 20px;*/

	}
	#videoPlayer {
		width: 100%;
		height: 50vh;
		/*background: #000;*/
		border: 1px solid #666; /* Basic border */
	}
	#videoPlayer::-webkit-media-controls {  /* Hide Progress Bar even paused */
		opacity: 0;
		transition: opacity 0.3s;
	}

	#videoPlayer:hover::-webkit-media-controls {
		opacity: 1;
	}

	/* Optional: For Firefox */
	#videoPlayer {
		-moz-user-select: none;
	}

	/* Alternative method if the above doesn't work */
	.video-container:hover #videoPlayer::-webkit-media-controls {
		opacity: 1;
	}
	.toolbar {
		background: #333;
		padding: 10px;
		margin: 10px 0;
		border-radius: 5px;
		color: white;
	}
	.toolbar button {
		padding: 5px 15px;
		margin: 0 5px;
		cursor: pointer;
		/*height: 20px;*/
	}
	textarea {
		width: 100%;
		height: 300px;
		margin-top: 20px;
		padding: 10px;
		font-family: monospace;
		font-size: 14px;
		line-height: 1.5;
		/* Add these properties for better selection visibility */
		caret-color: blue;
		selection-background-color: #b3d4fc;
	}
	/* For webkit browsers */
	textarea::selection {
		background: #b3d4fc;
	}
	#contentArea {
		resize: both;
		white-space: pre;
	}
	#contentArea[readonly] {
		background-color: #f0f0f0;
		cursor: default;
	}
	#contentArea[readonly]:focus {
		border-color: #f0f0f0;
		box-shadow: 0 0 80px rgba(243, 33, 150 , 0.4);
	}
	#contentArea:focus {
		border-color: #2196F3;
		box-shadow: 0 0 80px rgba(33, 150, 243, 0.4);
	}
	#currentTimecode {
		display: inline-block;
		margin-left: 20px;
		font-family: monospace;
	}
	#currentFilename {
		display: inline-block;
		margin-left: 20px;
		font-family: monospace;
	}
	button[onclick="saveToLocal()"] {
		transition: background-color 0.3s;
	}
	/* Optional: Add save indicator */
	button[onclick="saveToLocal()"]::after {
		content: '';
		display: inline-block;
		border-radius: 50%;
		margin-left: 5px;
		background-color: transparent;
	}
	button[onclick="saveToLocal()"].saving::after {
		background-color: #ffb700;
	}
	button[onclick="saveToLocal()"].saved::after {
		background-color: #00ff00;
	}
	.clear-button {
		transition: background-color 0.3s;
	}
	.clear-button:hover {
		background-color: #ffeeee; /* Light red hover effect */
	}
	button[onclick="toggleCurrentLine()"] {
		transition: background-color 0.3s;
	}
	button[onclick="toggleCurrentLine()"].toggled {
		background-color: #e0e0e0;
	}

	.button-style {
		display: inline-block;
		padding: 4px 8px;
		background-color: #f0f0f0;
		border: 1px solid #ccc;
		border-radius: 4px;
		text-decoration: none;
		color: black;
		cursor: pointer;
		margin-left: 5px;
		margin-right: 5px;
	}

	.button-style:hover {
		background-color: #e0e0e0;
	}

	.item {
		display: inline-block;
		padding: 0 15px;
		border-right: 1px solid #ccc;
	}
	.item:last-child {
		border-right: none;
	}
	#dropZone {
		background: #f8f9fa;
		border-radius: 4px;
		cursor: pointer;
		transition: all 0.3s ease;
	}

	#dropZone:hover {
		background: #e9ecef;
	}

	summary {
		cursor: pointer;
	}
      </style>
   </head>
   <body>
      <div class="container">
      <div class="video-container">
         <video id="videoPlayer" controls crossorigin="anonymous">
            <source src="" type="video/mp4">
	    
            Your browser does not support the video element.
         </video>
      </div>
      <div class="toolbar">
         <button title="outside: Space; inside: Shift-Space" id="playPauseButton" onclick="togglePlayPause()">‚ñ∂</button>
         <button title="outside: Left" onclick="seekBack()">-3s</button>
         <button title="outside: Right" onclick="seekForward()">+6s</button>
         <button title="s" onclick="findCurrentPosition()">Seek‚ñº</button>
         <button title="inside: Shift-Backspace; outside: (Shift)-Backspace" onclick="toggleCurrentLine()">(un)X</button>  
         <button title="outside: i" onclick="markInPoint()">IN‚ñº</button> 
         <button title="outside: o" onclick="markOutPoint()">OUT‚ñº</button>  
         <button title="Ctrl-s" onclick="saveToLocal()">üíæ Local</button>
         <button id="toggleReadonlyButton" title="Toggle Readonly: ESC" onclick="toggleReadonly()">üñãÔ∏è</button>
         <button id="toggleSeekUpButton" title="Toggle Seek Up: ` Backquote " onclick="toggleSeekUp()">üîó‚ñ≤</button>
         <span id="currentTimecode">00:00:00,000</span>
         <span id="currentFilename"></span>
      </div>
      <div class="textarea-container">
         <textarea id="contentArea" spellCheck="false" placeholder="Paste tsv EDL content here... (can be generated by srt2tsv.py)
            or cat some.srt | sed -n -r '1{/^$/n;};/^[0-9]+$/{n; s/ --> /\t/; s/$/\t| _CLIPNAME_ |\t/; N; s/\n//; h; d;}; /^$/! { H; $!d;}; x; s/\n/\\N/g; s/^/EDL\t/;p' > some.tsv

            Format: EDL[tab]00:00:00,000[tab]00:00:00,000[tab]| Filename |[tab]Subtitle
            Example:
	    EDL	00:03:12,125	00:03:14,394	| VideoClip1 |	We have Wang Kang here from Alibaba
            EDL	00:03:14,394	00:03:17,030	| VideoClip1 |	Group. He's a staff security engineer.
	    "></textarea>
      </div>
      <div style="margin-top: 10px;">
	      <details open> <summary> ADVANCED CONFIGURATION </summary>

      <div class="toolbar">
	      <a href="https://github.com/scateu/tsv_edl.vim/blob/main/utils/tsv2roughcut.py" target="_blank" class="button-style"> tsv2roughcut.py </a>
	      <a href="https://github.com/scateu/tsv_edl.vim/blob/main/utils/srt2tsv.py" target="_blank" class="button-style"> srt2tsv.py </a>
	      <a href="https://github.com/scateu/tsv_edl.vim/blob/main/html/rcut2.html" target="_blank" class="button-style"> rcut2.html </a>
	      <a href="https://github.com/scateu/tsv_edl.vim/blob/main/utils/tsv2fcpxml.py" target="_blank" class="button-style"> tsv2fcpxml.py </a>
	      <a href="https://evermeet.cx/ffmpeg/" target="_blank" class="button-style"> ffmpeg (mac static) </a>
	      <a href="https://github.com/scateu/tsv_edl.vim" target="_blank" class="button-style"> Project Home </a>
	      <a href="https://github.com/scateu/tsv_edl.vim/blob/main/html/docs.txt" target="_blank" class="button-style"> HELP </a>
         <button onclick="reloadMedia()">Reload Media</button> 
         <button class="clear-button" onclick="clearSavedContent()" >üóë Local</button> 
      </div>
		      <div class="config-zone" style="margin-top: 10px; margin-bottom: 10px; padding: 10px; border: 1px solid #ccc;">
			  <span class="item">
			    Media URL: <span id="currentMediaURL" style="font-family: monospace;">will be PREFIX/path/clipname.mp4</span></span>
			  </span>
			  <span class="separator">  </span>
			  <span class="item">
			    <span>Prefix: <span id="currentPrefix" style="font-family: monospace;"></span></span>
			    <button onclick="setPrefix()">SET</button>
			    <button onclick="clearPrefix()">CLR</button>
			  </span>
			  <span class="item">
			  <span class="separator">  </span>
			    <span>ext. name Suffix: <span id="currentSuffix" style="font-family: monospace;">.mp4</span></span>
			    <!--<button onclick="setSuffix()">SET</button>
			    <button onclick="clearSuffix()">CLR</button> -->
			  </span>
			</div>
		      <div id="dropZone" style="border: 2px dashed #ccc; padding: 20px; text-align: center; margin: 10px 0;">
			  Drag & Drop .srt file here to convert into tsv EDL lines. Will append to edit area.
			      <input type="file" id="fileInput" accept=".srt" style="display: none;">
                     </div>
		      <div class="toolbar">
			      <button onclick="loadTextFromURL()"> Load Sample EDL</button>
			      <button onclick="loadSample2()"> Sample: Bunny</button>
	                     <a href="https://youtu.be/p7HuFz-RwsI" target="_blank" class="button-style"> Youtube Demo 1</a>
	                     <a href="https://youtu.be/wakjF79oBY4" target="_blank" class="button-style"> Youtube Demo 2</a>
	                     <a href="https://www.bilibili.com/video/BV1sRQ2YVEdx/" target="_blank" class="button-style"> B: Demo 2</a>
		      </div>
		      <!--<div>
			 <textarea id="debug1" placeholder="Debug Info 1"></textarea>
		      </div> -->
	      </details>
      </div>
      <script>
	      const filenameDisplay = document.getElementById('currentFilename');
	      const mediaURLDisplay = document.getElementById('currentMediaURL');
	      //let currentFilename = "Authenticate2023-alibaba.mp4"; // Default filename
	      let currentFilename = ""; // Default filename
	      //let currentClipName = "Authenticate2023-alibaba"; // Remove .mp4 extension for comparison
	      let currentClipName = ""; // Remove .mp4 extension for comparison
	      let lastKnownCursorPosition = 0; // to maintain cursor position of textarea contentArea

	      const videoPlayer = document.getElementById('videoPlayer');
	      const textarea = document.getElementById('contentArea');
	      const timecodeDisplay = document.getElementById('currentTimecode');
	      const playPauseButton = document.getElementById('playPauseButton');

	      let isTextAreaFocused = false;  // Track focus state
	      let doSeekUp = true; // üîó‚ñ≤ ‚õìÔ∏è

	      // Set initial filename when page loads
	      filenameDisplay.textContent = currentFilename;

	      function togglePlayPause() {
		      if (videoPlayer.paused) {
			      videoPlayer.play();
			      playPauseButton.textContent = '‚è∏Ô∏é';
			      playPauseButton.style.backgroundColor = '#ccffcc'; // Optional: visual feedback
		      } else {
			      videoPlayer.pause();
			      playPauseButton.textContent = '‚ñ∂';
			      playPauseButton.style.backgroundColor = ''; // Reset button color
		      }
	      }
	      function doPlay() {
		      if (videoPlayer.paused) {
			      togglePlayPause();
		      } 
	      }
	      function doPause() {
		      if (!videoPlayer.paused) {
			      togglePlayPause();
		      } 
	      }

	      // Update button text when video state changes
	      videoPlayer.addEventListener('play', () => {
		      playPauseButton.textContent = '‚è∏Ô∏é';
		      playPauseButton.style.backgroundColor = '#ccffcc'; // Optional: visual feedback
	      });

	      videoPlayer.addEventListener('pause', () => {
		      playPauseButton.textContent = '‚ñ∂'; //U+25B6
		      playPauseButton.style.backgroundColor = ''; 
	      });

	      //utils
	      function isValidTimecode(timecode) {
		      // Check format: HH:MM:SS,mmm
		      //   const regex = /^([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]),([0-9]{3})$/;
		      const regex = /^\d\d:\d\d:\d\d,\d\d\d$/;
		      return regex.test(timecode);
	      }
	      function timecodeToSeconds(timecode) {
		      if (!isValidTimecode(timecode)) {
			      console.error('timecodeToSeconds: Invalid timecode format. Expected HH:MM:SS,mmm' + '   ' + timecode);
			      return 0;
		      }
		      const parts = timecode.split(/[:,]/);
		      const hours = parseInt(parts[0], 10);
		      const minutes = parseInt(parts[1], 10);
		      const seconds = parseInt(parts[2], 10);
		      const milliseconds = parseInt(parts[3], 10);
		      return (hours * 3600) + (minutes * 60) + seconds + (milliseconds / 1000);
	      }

	      function secondsToTimecode(seconds) {
		      const hours = Math.floor(seconds / 3600);
		      seconds %= 3600;
		      const minutes = Math.floor(seconds / 60);
		      seconds %= 60;
		      const wholeSeconds = Math.floor(seconds);
		      const milliseconds = Math.floor((seconds - wholeSeconds) * 1000);

		      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(wholeSeconds).padStart(2, '0')},${String(milliseconds).padStart(3, '0')}`;
	      }


	      function getCurrentLineContent() {
		      // Get the full content of the textarea
		      const fullText = textarea.value;
		      // Use the last known position if textarea is not focused
		      const cursorPosition = textarea.matches(':focus') ? 
			      textarea.selectionStart : 
			      lastKnownCursorPosition;

		      // Find the start of the current line by searching backwards for a newline
		      const lineStart = fullText.lastIndexOf('\n', cursorPosition - 1) + 1;

		      // Find the end of the current line by searching forwards for a newline
		      let lineEnd = fullText.indexOf('\n', cursorPosition);
		      if (lineEnd === -1) {
			      lineEnd = fullText.length; // If no newline is found, it's the end of the text
		      }

		      // Extract the line content
		      const lineContent = fullText.substring(lineStart, lineEnd);

		      // Calculate relative cursor position
		      let relativePosition = 0;
		      const parts = lineContent.split('\t');

		      if (parts.length >= 5) {  // Valid EDL line with at least 5 columns
			      // Calculate tab positions
			      let subtitleColumnStart = 0;
			      for (let i = 0; i < 4; i++) {  // Sum lengths of first 4 columns plus tabs
				      subtitleColumnStart += parts[i].length + 1;  // +1 for tab
			      }

			      const subtitleColumnEnd = lineEnd;
			      const subtitleLength = lineEnd - lineStart - subtitleColumnStart;

			      // Calculate relative position
			      if (cursorPosition <= lineStart + subtitleColumnStart) {
				      relativePosition = 0;
			      } else if (cursorPosition >= lineEnd) {
				      relativePosition = 1.0;
			      } else {
				      // Calculate position within subtitle
				      const positionInSubtitle = cursorPosition - (lineStart + subtitleColumnStart);
				      relativePosition = positionInSubtitle / subtitleLength;
			      }
		      }

		      return {
			      content: lineContent,
			      cursorRelativePosition: relativePosition
		      };
	      }

	      function processEDLLine(lineResult) {
		      const line = lineResult.content;
		      const linePosition = lineResult.cursorRelativePosition;

		      const parts = line.split('\t');
		      if (parts.length >= 5 && parts[0] === 'EDL') {
			      const timecodeIn = parts[1].trim();
			      const timecodeOut = parts[2].trim();
			      const clipName = parts[3].replace(/\|/g, '').trim();
			      const subtitle = parts[4];

			      // Validate timecodeIn
			      if (!isValidTimecode(timecodeIn)) {
				      console.log('Invalid timecode format:', timecodeIn, '(Expected HH:MM:SS,mmm)');
				      return 'Invalid timecode format';
			      }

			      const timeAtCursor = timecodeToSeconds(timecodeIn) + linePosition * (timecodeToSeconds(timecodeOut) - timecodeToSeconds(timecodeIn));

			      // Check if clipName is different than current
			      if (clipName && clipName !== currentClipName) {
				      // Update current clip name
				      currentClipName = clipName;

				      // Construct new video path
				      const newVideoPath = clipName + ".mp4";

				      // Change video
				      console.log(`Changing video to: ${newVideoPath}`);
				      changeVideo(newVideoPath);

				      // After changing video, we need to wait for the video to load
				      // before seeking to the correct timecode
				      videoPlayer.addEventListener('loadeddata', function seekAfterLoad() {
					      videoPlayer.currentTime = timeAtCursor;
					      videoPlayer.removeEventListener('loadeddata', seekAfterLoad);
				      });
			      } else {
				      // If same video, just seek to the new position
				      videoPlayer.currentTime = timeAtCursor;
			      }

			      // Update filename display
			      filenameDisplay.textContent = currentClipName;

			      // Update Media URL
			      mediaURLDisplay.textContent = videoPlayer.src;

			      console.log(`Seeking to ${timecodeIn} (${timecodeToSeconds(timecodeIn)} seconds)`);
		      }
	      }

	      function changeVideo(videoPath) {
		      const prefix = localStorage.getItem('videoUrlPrefix') || '';
		      const fullPath = prefix + videoPath;

		      // Store current play state before changing source
		      const wasPlaying = !videoPlayer.paused;

		      //videoPlayer.play(); // maintain previous play status


		      // Remove any existing canplay listeners
		      const playHandler = () => {
			      if (wasPlaying) {
				      videoPlayer.play();
			      }
			      videoPlayer.removeEventListener('canplay', playHandler);
		      };

		      // Add listener before changing source
		      videoPlayer.addEventListener('canplay', playHandler);

		      videoPlayer.src = fullPath;

		      // Update currentClipName (remove .mp4 extension)
		      currentClipName = videoPath.replace('.mp4', '');

		      // Update filename display
		      filenameDisplay.textContent = currentClipName;
	      }


	      function seekBack() {
		      videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime - 3);
	      }

	      function seekForward() {
		      videoPlayer.currentTime = Math.min(videoPlayer.duration, videoPlayer.currentTime + 6);
	      }

	      textarea.addEventListener('blur', () => {
		      lastKnownCursorPosition = textarea.selectionStart;
	      });

	      textarea.addEventListener('click', () => {
		      lastKnownCursorPosition = textarea.selectionStart;
		      showCaret();
	      });

	      textarea.addEventListener('keyup', () => {
		      lastKnownCursorPosition = textarea.selectionStart;
	      });

	      function toggleCurrentLine() {
		      // Use the last known position if textarea is not focused
		      const cursorPosition = textarea.matches(':focus') ? 
			      textarea.selectionStart : 
			      lastKnownCursorPosition;

		      const lines = textarea.value.split('\n');
		      let currentLineIndex = textarea.value.substr(0, cursorPosition).split('\n').length - 1;
		      const currentLine = lines[currentLineIndex];

		      if (currentLine) {
			      const parts = currentLine.split('\t');
			      if (parts.length >= 1) {
				      // Toggle between 'EDL' and 'xxx'
				      parts[0] = (parts[0] === 'EDL') ? 'xxx' : 'EDL';

				      // Rejoin the line with tabs
				      const newLine = parts.join('\t');

				      // Replace the current line in the array
				      lines[currentLineIndex] = newLine;

				      // Update textarea content
				      textarea.value = lines.join('\n');

				      // Maintain cursor position
				      /*const beforeText = lines.slice(0, currentLineIndex).join('\n');
				      const newCursorPosition = beforeText.length + (currentLineIndex > 0 ? 1 : 0) + newLine.length;
				      */
				      textarea.setSelectionRange(lastKnownCursorPosition, lastKnownCursorPosition);

				      // Visual feedback
				      textarea.style.backgroundColor = "rgba(243, 33, 150, 0.4)";
				      setTimeout(() => {
					      textarea.style.backgroundColor = '';
				      }, 100);
			      }
		      }
		      // preserve textarea.focus status
		      //if (isTextAreaFocused) {
			      textarea.focus();
			      isTextAreaFocused = true;
		      //}
		      showCaret();
	      }

	      function findCurrentPosition() {
		      //video bar postion to edl file position
		      const currentTime = videoPlayer.currentTime;
		      const currentClip = filenameDisplay.textContent; // Get current filename
		      const lines = textarea.value.split('\n');
		      let nearestLine = null;
		      let nearestDiff = Infinity;
		      let nearestIndex = -1;

		      lines.forEach((line, index) => {
			      const parts = line.split('\t');
			      if (parts.length >= 3 && parts[0] === 'EDL') {
				      const inTime = timecodeToSeconds(parts[1]);
				      const outTime = timecodeToSeconds(parts[2]);
				      const clipName = parts[3].replace(/\|/g, '').trim();

				      // Only consider lines that match the current clip
				      if (clipName === currentClip) {
					      // Check if current time is within this segment
					      if (currentTime >= inTime && currentTime <= outTime) {
						      nearestLine = line;
						      nearestIndex = index;
						      nearestDiff = 0;
						      return;
					      }

					      // If not within any segment, find the nearest one
					      const diffIn = Math.abs(currentTime - inTime);
					      const diffOut = Math.abs(currentTime - outTime);
					      const minDiff = Math.min(diffIn, diffOut);

					      if (minDiff < nearestDiff) {
						      nearestDiff = minDiff;
						      nearestLine = line;
						      nearestIndex = index;
					      }
				      }
			      }
		      });

		      if (nearestLine) {
			      // Calculate the position to place the cursor
			      const lineStartPosition = textarea.value.split('\n')
				      .slice(0, nearestIndex)
				      .join('\n').length + (nearestIndex > 0 ? 1 : 0);
			      const lineEndPosition = lineStartPosition + nearestLine.length;

			      // Focus and select the line
			      textarea.focus();
			      textarea.setSelectionRange(lineStartPosition, lineEndPosition);

			      // Scroll to the line
			      const lineHeight = textarea.scrollHeight / lines.length;
			      const scrollPosition = lineHeight * nearestIndex;

			      // Center the line in the textarea viewport
			      textarea.scrollTop = scrollPosition - (textarea.clientHeight / 2) + (lineHeight / 2);

			      // Optional: Add temporary highlight effect
			      const originalColor = textarea.style.backgroundColor;
			      textarea.style.backgroundColor = '#ffffd0'; // Light yellow highlight
			      setTimeout(() => {
				      textarea.style.backgroundColor = originalColor;
			      }, 1000); // Remove highlight after 1 second

			      console.log(`Found matching line for clip ${currentClip} at time ${currentTime}`);
		      } else {
			      console.log(`No matching line found for clip ${currentClip} at time ${currentTime}`);
		      }
	      }


	      function markInPoint() {
		      //TODO append a new line after cursor, instead of in the end.
		      // Get current video time
		      const currentTime = videoPlayer.currentTime;
		      const timecode = secondsToTimecode(currentTime);


		      // Get current filename and remove extension
		      let clipName = filenameDisplay.textContent;
		      clipName = clipName.replace(/\.[^.]+$/, ''); // Remove any extension after the last dot


		      // Create new EDL line
		      const newEDLLine = `EDL\t${timecode}\t${timecode}\t| ${clipName} |\tSELECTION`;

		      // Append to textarea
		      textarea.value += (textarea.value && !textarea.value.endsWith('\n') ? '\n' : '') + newEDLLine;

		      // Optional: Scroll textarea to bottom to show new line
		      textarea.scrollTop = textarea.scrollHeight;

		      // Optional: Flash feedback to user
		      textarea.style.backgroundColor = '#ffffd0';
		      setTimeout(() => {
			      textarea.style.backgroundColor = '';
		      }, 200);
	      }

	      function markOutPoint() {
		      //TODO append a new line after cursor, instead of in the end.
		      // Get current video time
		      const currentTime = videoPlayer.currentTime;
		      const timecode = secondsToTimecode(currentTime);

		      // Get all lines, ensuring we handle empty textarea and trailing newlines properly
		      let content = textarea.value;
		      if (!content) {
			      // If textarea is empty, create new EDL line
			      let clipName = filenameDisplay.textContent;
			      clipName = clipName.replace(/\.[^.]+$/, '');
			      textarea.value = `EDL\t${timecode}\t${timecode}\t| ${clipName} |\t\n`;
			      return;
		      }

		      // Remove trailing newline if exists for consistent handling
		      content = content.replace(/\n$/, '');
		      const lines = content.split('\n');
		      const lastLine = lines[lines.length - 1];

		      if (lastLine.startsWith('EDL')) {
			      // Split and preserve all tabs
			      const parts = lastLine.split('\t');
			      // Update only the out timecode (index 2)
			      parts[2] = timecode;
			      // Replace last line while preserving exact tab structure
			      lines[lines.length - 1] = parts.join('\t');
			      // Update textarea with proper line ending
			      textarea.value = lines.join('\n') + '\n';
		      } else {
			      // If last line is not EDL, append new line
			      let clipName = filenameDisplay.textContent;
			      clipName = clipName.replace(/\.[^.]+$/, '');
			      textarea.value = content + (content ? '\n' : '') +
				      `EDL\t${timecode}\t${timecode}\t| ${clipName} |\t\n`;
		      }

		      // Scroll to bottom and set cursor at end
		      /*
		      textarea.scrollTop = textarea.scrollHeight;
		      textarea.setSelectionRange(textarea.value.length, textarea.value.length);
		      */

		      // Visual feedback
		      textarea.style.backgroundColor = '#ffffd0';
		      setTimeout(() => {
			      textarea.style.backgroundColor = '';
		      }, 200);
	      }

	      ////////////////// KEY BINDING START ///////////////////////
	      document.addEventListener('keydown', function(e) {
		      if (e.target.tagName !== 'TEXTAREA') { // outside only
			      if (e.key === 's' || e.key === 'S') {
				      e.preventDefault(); // Prevent default 'find' dialog in browser
				      findCurrentPosition();
			      }
			      // Check if the pressed key is spacebar and the target is not the textarea
			      if (e.code === 'Space' || e.key === 'k') { //TODO j k l 
				      e.preventDefault(); // Prevent page scrolling
				      togglePlayPause();
			      }
			      if (e.key === 'l') { 
				      e.preventDefault();
				      doPlay();
			      }
			      // Optional: Add keyboard shortcut (e.g., 'I' key)
			      if (e.key === 'i' || e.key === 'I') {
				      e.preventDefault();
				      markInPoint();
			      }
			      if (e.key === 'o' || e.key === 'O') {
				      e.preventDefault();
				      markOutPoint();
			      }
			      //if (e.key === 'x' || e.key === 'X') { // backspace or S-backspace
		              if ( e.key === 'Backspace' || (e.key === 'Backspace' && e.shiftKey && !e.ctrlKey && !e.altKey)) { //Backspace or Shift-Backspace
				      e.preventDefault();
				      toggleCurrentLine();
			      }
			      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') { // prevent unnecessary scrolling by arrow up/down
				      e.preventDefault();
			      }
			      if (e.key === 'ArrowLeft') { 
				      e.preventDefault();
				      seekBack();
			      }
			      if (e.key === 'ArrowRight') { 
				      e.preventDefault();
				      seekForward();
			      }
//			      if (e.key === '.') {   // FIXME
//				      e.preventDefault();
//				      videoPlayer.seekToNextFrame();
//			      }
		      } 
		      // inside only key handled in textarea.addEventListener('keydown', ....)

		      // both inside and outside textarea. in whole document area.
		      if (e.key === 'Escape') { // do focus in textarea
			      e.preventDefault();
			      e.stopPropagation();
			      /*textarea.focus();
				isTextAreaFocused = true;*/
			      document.getElementById('toggleReadonlyButton').focus();  // first unfocus. otherwise caret won't preserve
			      toggleReadonly();
			      textarea.focus();
			      isTextAreaFocused = true;
		      }
		      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
			      e.preventDefault(); // Prevent browser's save dialog
			      saveToLocal();
		      }

		      // Shift + minus: decrease video size
		      if (e.shiftKey && e.key === '_') {  // Shift + minus key
			      const currentHeight = videoPlayer.offsetHeight;
			      e.preventDefault();
			      videoPlayer.style.height = (currentHeight * 0.9) + 'px';  // Decrease by 10%
		      }

		      // Shift + plus: increase video size
		      if (e.shiftKey && e.key === '+') {  // Shift + plus key
			      const currentHeight = videoPlayer.offsetHeight;
			      e.preventDefault();
			      videoPlayer.style.height = (currentHeight * 1.1) + 'px';  // Increase by 10%
		      }

		      // Shift + 0: reset to default size
		      if (e.shiftKey && e.key === ')') {  // Shift + 0 key
			      const currentHeight = videoPlayer.offsetHeight;
			      e.preventDefault();
			      videoPlayer.style.height = '100%';  // Reset to original size
		      }                

		      // ESC
		      if (e.key === '`') {
			      e.preventDefault();
			      /*if (isTextAreaFocused) {
				      // If textarea is focused, blur it 
				      textarea.blur(); // Esc explicitly bind to UnFocus textarea. As in Vim.
				      isTextAreaFocused = false;
			      } else {
				      // If textarea is not focused, focus it
				      textarea.focus();
				      isTextAreaFocused = true;
			      }*/
			      toggleSeekUp();
		      }

	      });


	      // Process EDL line when cursor moves
	      textarea.addEventListener('click', function() {
		      if (!doSeekUp) { 
			      return // do nothing
		      }
		      const currentLine = getCurrentLineContent();
		      if (currentLine) {
			      processEDLLine(currentLine);
		      }
	      });

	      textarea.addEventListener('keyup', function(e) {
		      if (!doSeekUp) {
			      return // do nothing 
		      }
		      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
			      const currentLine = getCurrentLineContent();
			      if (currentLine) {
				      processEDLLine(currentLine);
			      }
			      showCaret();
		      }
	      });

	      textarea.addEventListener('keydown', function(e) {
		      if (e.key === 'Tab') { //input a Tab
			      e.preventDefault(); // Prevent default tab behavior
			      if (!this.readOnly) {
				      // Get cursor position
				      const start = this.selectionStart;
				      const end = this.selectionEnd;

				      // Insert tab at cursor position
				      this.value = this.value.substring(0, start) + '\t' + this.value.substring(end);

				      // Move cursor after tab
				      this.selectionStart = this.selectionEnd = start + 1;
			      }
		      }

		      // RED / BLUE MODE
		      if (e.key === 'Backspace' && e.shiftKey && !e.ctrlKey && !e.altKey) { //Shift-Backspace
			      e.preventDefault();
			      toggleCurrentLine();
		      }
		      if (e.key === ' ' && e.shiftKey && !e.ctrlKey && !e.altKey) { // Shift-Space
			      e.preventDefault();
			      togglePlayPause();
		      }


		      if (this.readOnly) { // can't write. RED MODE
			      if (e.key === ' ')  { // Space
				      e.preventDefault();
				      togglePlayPause();
			      }
			      if (e.key === 'Backspace')  { // Backspace
				      e.preventDefault();
				      toggleCurrentLine();
			      }
			      if (e.key === 'i' || e.key === 'I') {
				      e.preventDefault();
				      markInPoint();
			      }
			      if (e.key === 'o' || e.key === 'O') {
				      e.preventDefault();
				      markOutPoint();
			      }
			      if (e.key === 's' || e.key === 'S') {
				      e.preventDefault();
				      findCurrentPosition();
			      }
			      if (e.key === 'Enter') { // same as click
				      e.preventDefault();
				      const currentLine = getCurrentLineContent();
				      if (currentLine) {
					      processEDLLine(currentLine);
				      }
			      }
			      if (e.key === '|') {
				      e.preventDefault();
				      //TODO  Split
			      }
			      if (e.key === 'j' || e.key === 'J') {
				      e.preventDefault();
				      //TODO  Join
			      }
		      } else { // only when writable
		      }
	      });
	      ////////////////// KEY BINDING END ///////////////////////

	      /////////////////   localStorage        ///////////////// 

	      // Function to save content to localStorage
	      function saveToLocal() {
		      const content = textarea.value;
		      try {
			      localStorage.setItem('edlContent', content);

			      // Visual feedback
			      const saveButton = document.querySelector('button[onclick="saveToLocal()"]');
			      const originalText = saveButton.textContent;
			      saveButton.textContent = 'Saved!';
			      saveButton.style.backgroundColor = '#90EE90'; // Light green

			      setTimeout(() => {
				      saveButton.textContent = originalText;
				      saveButton.style.backgroundColor = '';
			      }, 1000);

			      console.log('Content saved to local storage');
		      } catch (e) {
			      console.error('Error saving to local storage:', e);
			      alert('Failed to save content!');
		      }
	      }

	      // Function to load content from localStorage
	      function loadFromLocal() {
		      try {
			      const savedContent = localStorage.getItem('edlContent');
			      if (savedContent) {
				      textarea.value = savedContent;
				      console.log('Content loaded from local storage');
			      }
		      } catch (e) {
			      console.error('Error loading from local storage:', e);
		      }
	      }


	      // Auto-save functionality (optional)
	      let autoSaveTimeout;
	      textarea.addEventListener('input', () => {
		      clearTimeout(autoSaveTimeout);
		      autoSaveTimeout = setTimeout(() => {
			      saveToLocal();
		      }, 2000); // Auto-save 2 seconds after last input
	      });

	      // Load content when page loads
	      document.addEventListener('DOMContentLoaded', loadFromLocal);

	      function clearSavedContent() {
		      // Show confirmation dialog
		      if (confirm('Are you sure you want to clear saved content? This cannot be undone.')) {
			      try {
				      // Clear localStorage
				      localStorage.removeItem('edlContent');

				      // Clear textarea
				      textarea.value = '';

				      // Visual feedback
				      const clearButton = document.querySelector('.clear-button');
				      const originalText = clearButton.textContent;
				      clearButton.textContent = 'Cleared!';
				      clearButton.style.backgroundColor = '#ff9999'; // Light red

				      setTimeout(() => {
					      clearButton.textContent = originalText;
					      clearButton.style.backgroundColor = '';
				      }, 1000);

				      console.log('Content cleared from local storage');
			      } catch (e) {
				      console.error('Error clearing local storage:', e);
				      alert('Failed to clear content!');
			      }
		      }
	      }
	      async function loadTextFromURL() {
		      // You can either hardcode the URL or use a prompt
		      const url = prompt("Enter URL of the text file:", "textarea.txt");

		      if (!url) return; // User cancelled the prompt

		      try {
			      const response = await fetch(url);
			      if (!response.ok) {
				      throw new Error(`HTTP error! status: ${response.status}`);
			      }
			      const text = await response.text();

			      // Get the textarea and set its value
			      const textarea = document.getElementById('contentArea');
			      
			      // Check if line one is PREFIX
			      let lines = text.split('\n');
			      let prefix = "";
			      let filteredLines = [];
			      for (let i = 0;i < lines.length; i++) {
				      const line = lines[i].trim();
				      if (line.startsWith("PREFIX:")) {
					      prefix = line.replace("PREFIX:","").trim();
					      console.log("[loadTextFromURL] PREFIX: " + prefix);
				      } else {
					      filteredLines.push(line);
				      }
			      }

			      localStorage.setItem('videoUrlPrefix', prefix);
			      updatePrefixDisplay();

			      textarea.value = filteredLines.join('\n');

			      // Trigger any necessary update events
			      const inputEvent = new Event('input');
			      textarea.dispatchEvent(inputEvent);

			      // Optional: Visual feedback
			      textarea.style.backgroundColor = '#ffffd0';
			      setTimeout(() => {
				      textarea.style.backgroundColor = '';
			      }, 200);

		      } catch (error) {
			      console.error('Error loading text:', error);
			      alert('Error loading text file. Check console for details.');
		      }
	      }
	      function loadSample2(){
		      const sample2 = `
EDL	00:00:00,000	00:09:56,474	| BigBuckBunny                 |	..........
EDL	00:00:00,000	00:10:53,803	| ElephantsDream               |	..........
EDL	00:00:00,000	00:00:15,022	| ForBiggerBlazes              |	..........
EDL	00:00:00,000	00:00:15,046	| ForBiggerEscapes             |	..........
EDL	00:00:00,000	00:01:00,070	| ForBiggerFun                 |	..........
EDL	00:00:00,000	00:00:15,046	| ForBiggerJoyrides            |	..........
EDL	00:00:00,000	00:00:15,046	| ForBiggerMeltdowns           |	..........
EDL	00:00:00,000	00:14:47,999	| Sintel                       |	..........
EDL	00:00:00,000	00:09:54,570	| SubaruOutbackOnStreetAndDirt |	..........
EDL	00:00:00,000	00:12:14,260	| TearsOfSteel                 |	..........
EDL	00:00:00,000	00:09:53,803	| VolkswagenGTIReview          |	..........
EDL	00:00:00,000	00:00:47,461	| WeAreGoingOnBullrun          |	..........
EDL	00:00:00,000	00:09:27,379	| WhatCarCanYouGetForAGrand    |	..........
`;
		      textarea.value = sample2;
		      localStorage.setItem('videoUrlPrefix', "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/");
		      updatePrefixDisplay();
		      reloadMedia();
	      }

	      function reloadMedia(){
		      //reload video
		      currentClipName = ""; // make it sure to invoke changeVideo()
		      const currentLine = getCurrentLineContent();
		      if (currentLine) {
			      processEDLLine(currentLine);
		      }
	      }

	      /////////// Media file url prefix adding
	      function setPrefix() {
		      const currentPrefix = localStorage.getItem('videoUrlPrefix') || '';
		      const prefix = prompt("Enter URL prefix for media:\n e.g.: https://video.scateu.me/\n       file:///Users/k/www/some/", currentPrefix);

		      if (prefix !== null) {  // if user didn't click Cancel
			      // Add trailing slash if missing
			      let normalizedPrefix = prefix.trim();
			      if (normalizedPrefix && !normalizedPrefix.endsWith('/')) {
				      normalizedPrefix += '/';
			      }
			      localStorage.setItem('videoUrlPrefix', normalizedPrefix);
			      updatePrefixDisplay();

			      //reload video
			      reloadMedia();
		      }
	      }

	      function clearPrefix() {
		      localStorage.removeItem('videoUrlPrefix');
		      updatePrefixDisplay();
		      reloadMedia();
	      }

	      // Update timecode display
	      videoPlayer.addEventListener('timeupdate', function() {
		      timecodeDisplay.textContent = secondsToTimecode(videoPlayer.currentTime);
	      });

	      function updatePrefixDisplay() {
		      const prefixDisplay = document.getElementById('currentPrefix');
		      const currentPrefix = localStorage.getItem('videoUrlPrefix');
		      prefixDisplay.textContent = currentPrefix || '(none)';
	      }

	      // Load saved prefix when page loads
	      document.addEventListener('DOMContentLoaded', () => {
		      updatePrefixDisplay();
	      });


	      //////////////// Drop zone to do srt2tsv

	      function setupDropZone() {
		      const dropZone = document.getElementById('dropZone');
		      const fileInput = document.getElementById('fileInput');

		      // Make dropZone clickable
		      dropZone.addEventListener('click', () => {
			      fileInput.click();
		      });

		      // Handle file selection via click
		      fileInput.addEventListener('change', (e) => {
			      handleFiles(e.target.files);
		      });

		      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
			      dropZone.addEventListener(eventName, preventDefaults, false);
		      });

		      function preventDefaults (e) {
			      e.preventDefault();
			      e.stopPropagation();
		      }

		      ['dragenter', 'dragover'].forEach(eventName => {
			      dropZone.addEventListener(eventName, highlight, false);
		      });

		      ['dragleave', 'drop'].forEach(eventName => {
			      dropZone.addEventListener(eventName, unhighlight, false);
		      });

		      function highlight(e) {
			      dropZone.style.backgroundColor = '#e3f2fd';
		      }

		      function unhighlight(e) {
			      dropZone.style.backgroundColor = '';
		      }

		      dropZone.addEventListener('drop', handleDrop, false);

		      function handleDrop(e) {
			      const dt = e.dataTransfer;
			      const files = dt.files;
			      handleFiles(files);
		      }

		      function handleFiles(files) {
			      const file = files[0];
			      if (file.name.toLowerCase().endsWith('.srt')) {
				      // Get filename without extension for clipname
				      const clipName = file.name.replace(/\.[^/.]+$/, "");

				      const reader = new FileReader();
				      reader.onload = function(e) {
					      const srtContent = e.target.result;
					      const edlLines = convertSrtToEdl(srtContent, clipName);

					      // Append to textarea
					      textarea.value += (textarea.value ? '\n' : '') + edlLines;

					      // Success message
					      dropZone.innerHTML = `Converted ${file.name} and appended!`;
					      setTimeout(() => {
						      dropZone.innerHTML = 'Drag & Drop .srt file here';
					      }, 2000);
				      };
				      reader.readAsText(file);
			      } else {
				      alert('Please drop a .srt file');
			      }
		      }
	      }

	      function convertSrtToEdl(srtContent, clipName) {
		      const lines = srtContent.split('\n');
		      let edlLines = [];
		      let currentEntry = {};

		      for (let i = 0; i < lines.length; i++) {
			      const line = lines[i].trim();

			      if (!line) continue;

			      if (/^\d+$/.test(line)) {
				      if (currentEntry.timeIn) {
					      edlLines.push(formatEdlLine(currentEntry, clipName));
				      }
				      currentEntry = {};
				      continue;
			      }

			      if (line.includes('-->')) {
				      const times = line.split('-->').map(t => t.trim());
				      currentEntry.timeIn = convertSrtTimeToEdlTime(times[0]);
				      currentEntry.timeOut = convertSrtTimeToEdlTime(times[1]);
				      continue;
			      }

			      if (currentEntry.timeIn && !currentEntry.text) {
				      currentEntry.text = line;
			      } else if (currentEntry.text) {
				      currentEntry.text += ' ' + line;
			      }
		      }

		      if (currentEntry.timeIn) {
			      edlLines.push(formatEdlLine(currentEntry, clipName));
		      }

		      return edlLines.join('\n');
	      }

	      function convertSrtTimeToEdlTime(srtTime) {
		      return srtTime.replace('.', ',');
	      }

	      function formatEdlLine(entry, clipName) {
		      // Use the filename as clipname
		      return `EDL\t${entry.timeIn}\t${entry.timeOut}\t| ${clipName} |\t${entry.text}`;
	      }

	      document.addEventListener('DOMContentLoaded', setupDropZone);

	      // Toggle Readonly of contentArea; useful in touch screen, like iPad and Tesla.
	      function toggleReadonly() {
		      textarea.readOnly = !textarea.readOnly; // Toggle readonly status
		      const readonlyButton = document.getElementById('toggleReadonlyButton');
		      readonlyButton.textContent = textarea.readOnly ? 'üîè' : 'üñãÔ∏è';
		      textarea.style.backgroundColor = textarea.readOnly ? '#f0f0f0' : 'white';
		      showCaret();
		      textarea.focus();
		      isTextAreaFocused = true;
	      }
	      function toggleSeekUp() {
		      doSeekUp = !doSeekUp;
		      const seekUpButton = document.getElementById('toggleSeekUpButton');
		      seekUpButton.textContent = doSeekUp ? 'üîó‚ñ≤' : '‚õìÔ∏è‚Äçüí•‚ñ≤';
	      }
	      function showCaret() { // a simple way to show cursor / caret by selecting a char.
		      if (textarea.selectionStart != textarea.selectionEnd) { // region selection
			      return
		      }

		      if (!textarea.readOnly) { // NOT READONLY, BLUE MODE
			      return // do nothing in BLUE mode
		      }

		      const cursorPosition = textarea.matches(':focus') ? 
			      textarea.selectionStart : 
			      lastKnownCursorPosition;
		      if (cursorPosition < textarea.value.length) {
			      if (textarea.value[cursorPosition] === '\n') {
				      textarea.setSelectionRange(cursorPosition-1, cursorPosition);
			      } else {
				      textarea.setSelectionRange(cursorPosition, cursorPosition +1);
			      } 
		       }else { // last char
			       //textarea.setSelectionRange(cursorPosition-1, cursorPosition);
		       }

	      }

      </script>
   </body>
</html>
<!-- with the help of claude35_sonnet2, Thank you! -->
<!-- !tidy -mi -html -wrap 0 % -->
